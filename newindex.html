<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>消灭魔王</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            height: 100vh;
            max-height: 600px;
        }
        
        canvas {
            background: #000;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.5);
            width: 100%;
            height: 100%;
        }
        
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            z-index: 10;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 20;
            display: none;
        }
        
        .win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 20;
            display: none;
        }
        
        h1 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 3rem;
            text-align: center;
        }
        
        .win-screen h1 {
            color: #2ed573;
        }
        
        h2 {
            color: #ffa502;
            margin-bottom: 10px;
            text-align: center;
        }
        
        button {
            padding: 12px 30px;
            background: #2ed573;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.2rem;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #1dd1a1;
            transform: scale(1.05);
        }
        
        .health-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            width: 100%;
            background: #2ed573;
            transition: width 0.3s ease;
        }
        
        .boss-health-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .boss-health-fill {
            height: 100%;
            width: 100%;
            background: #ff4757;
            transition: width 0.3s ease;
        }
        
        .skill-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .skill-button {
            width: 60px;
            height: 60px;
            background: #ff9f43;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            text-align: center;
            user-select: none;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        
        .skill-button.available {
            opacity: 1;
            box-shadow: 0 0 15px #ff9f43;
        }
        
        .mobile-controls {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 150px;
            height: 150px;
            display: none;
        }
        
        .joystick {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute;
            bottom: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .joystick-handle {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
        }
        
        .phase-indicator {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: none;
        }
        
        .phase-1 {
            background: #ff4757;
        }
        
        .phase-2 {
            background: #ff3838;
            animation: pulse 1s infinite;
        }
        
        .phase-3 {
            background: #b71540;
            animation: pulse 0.5s infinite;
        }
        
        .boss-skill-indicator {
            position: absolute;
            top: 90px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            display: none;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px currentColor; }
            50% { box-shadow: 0 0 20px currentColor; }
            100% { box-shadow: 0 0 5px currentColor; }
        }
        
        /* 响应式设计 */
        @media (max-width: 800px), (max-height: 600px) {
            .game-container {
                height: 100vh;
                max-height: none;
                border-radius: 0;
            }
            
            canvas {
                border-radius: 0;
            }
            
            .mobile-controls {
                display: block;
            }
            
            .controls {
                display: none;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .ui, .boss-health-bar {
                font-size: 14px;
            }
            
            .health-bar, .boss-health-bar {
                width: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="phase-indicator" id="phaseIndicator">Boss 第一阶段</div>
        <div class="boss-skill-indicator" id="bossSkillIndicator"></div>
        
        <div class="ui">
            <h2>得分: <span id="score">0</span></h2>
            <div>生命值:</div>
            <div class="health-bar">
                <div class="health-fill" id="playerHealth"></div>
            </div>
        </div>
        
        <div class="boss-health-bar">
            <div>Boss生命值:</div>
            <div class="health-bar">
                <div class="boss-health-fill" id="bossHealth"></div>
            </div>
        </div>
        
        <div class="controls">
            <p>移动: W A S D</p>
            <p>技能: K (一局一次)</p>
            <p>目标: 躲避Boss攻击并生存!</p>
        </div>
        
        <div class="skill-indicator">
            <div>终极技能</div>
            <div class="skill-button" id="skillButton">K</div>
        </div>
        
        <div class="mobile-controls">
            <div class="joystick" id="joystick">
                <div class="joystick-handle"></div>
            </div>
        </div>
        
        <div class="game-over" id="gameOverScreen">
            <h1>你输了!</h1>
            <h2>最终得分: <span id="finalScore">0</span></h2>
            <button id="restartButton">重新开始</button>
        </div>
        
        <div class="win-screen" id="winScreen">
            <h1>你赢了!</h1>
            <h2>最终得分: <span id="winScore">0</span></h2>
            <button id="winRestartButton">重新开始</button>
        </div>
    </div>

    <script>
        // ===========================================
        // 开发者自定义区域 - 可以修改以下配置
        // ===========================================
        
        // 玩家图片URL - 替换为您想要的玩家图片
        const PLAYER_IMAGE_URL = 'ljk.png'; // 留空使用默认图形
        
        // Boss图片URL - 替换为您想要的Boss图片
        const BOSS_IMAGE_URL = 'boss.png'; // 留空使用默认图形
        
        // Boss血量设置（默认300）
        const BOSS_MAX_HEALTH = 400;
        
        // 玩家血量设置（默认100）
        const PLAYER_MAX_HEALTH = 1200;
        
        // 玩家技能伤害（默认30）
        const PLAYER_SKILL_DAMAGE = 20;
        
        // ===========================================
        // 游戏初始化
        // ===========================================
        
        // 获取Canvas和上下文
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // 初始调整尺寸
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 游戏状态
        let score = 0;
        let gameOver = false;
        let playerHealth = PLAYER_MAX_HEALTH;
        let bossHealth = BOSS_MAX_HEALTH;
        let bossPhase = 1;
        let skillAvailable = true;
        
        // 玩家对象
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: 40,
            height: 40,
            speed: 5,
            color: '#2ed573',
            image: null
        };
        
        // Boss对象
        const boss = {
            x: canvas.width / 2,
            y: 100,
            width: 100,
            height: 100,
            color: '#ff4757',
            attackCooldown: 0,
            attackRate: 60, // 攻击频率（帧数）
            phase2Triggered: false,
            phase3Triggered: false,
            skillCooldown: 0,
            skillType: 0,
            moveDirection: 1,
            moveSpeed: 2,
            image: null
        };
        
        // 子弹数组
        const bullets = [];
        const enemyBullets = [];
        const specialAttacks = [];
        
        // 键盘状态
        const keys = {};
        
        // 触摸控制
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoveX = 0;
        let touchMoveY = 0;
        let isTouching = false;
        
        // ===========================================
        // 游戏核心函数
        // ===========================================
        
        // 加载图片
        function loadImages() {
            // 加载玩家图片
            if (PLAYER_IMAGE_URL) {
                player.image = new Image();
                player.image.src = PLAYER_IMAGE_URL;
                player.image.onerror = function() {
                    console.error('玩家图片加载失败，使用默认图形');
                    player.image = null;
                };
            }
            
            // 加载Boss图片
            if (BOSS_IMAGE_URL) {
                boss.image = new Image();
                boss.image.src = BOSS_IMAGE_URL;
                boss.image.onerror = function() {
                    console.error('Boss图片加载失败，使用默认图形');
                    boss.image = null;
                };
            }
        }
        
        // 初始化游戏
        function init() {
            score = 0;
            gameOver = false;
            playerHealth = PLAYER_MAX_HEALTH;
            bossHealth = BOSS_MAX_HEALTH;
            bossPhase = 1;
            skillAvailable = true;
            player.x = canvas.width / 2;
            player.y = canvas.height - 100;
            boss.x = canvas.width / 2;
            boss.y = 100;
            boss.phase2Triggered = false;
            boss.phase3Triggered = false;
            boss.moveDirection = 1;
            bullets.length = 0;
            enemyBullets.length = 0;
            specialAttacks.length = 0;
            
            // 加载图片
            loadImages();
            
            updateHealthBars();
            updateSkillIndicator();
            updatePhaseIndicator();
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('winScreen').style.display = 'none';
        }
        
        // 更新玩家生命值显示
        function updateHealthBars() {
            document.getElementById('playerHealth').style.width = (playerHealth / PLAYER_MAX_HEALTH * 100) + '%';
            document.getElementById('bossHealth').style.width = (bossHealth / BOSS_MAX_HEALTH * 100) + '%';
        }
        
        // 更新技能指示器
        function updateSkillIndicator() {
            const skillButton = document.getElementById('skillButton');
            if (skillAvailable) {
                skillButton.classList.add('available');
            } else {
                skillButton.classList.remove('available');
            }
        }
        
        // 更新阶段指示器
        function updatePhaseIndicator() {
            const phaseIndicator = document.getElementById('phaseIndicator');
            phaseIndicator.textContent = `Boss 第${bossPhase}阶段`;
            phaseIndicator.className = 'phase-indicator phase-' + bossPhase;
            phaseIndicator.style.display = 'block';
            
            // 3秒后隐藏指示器
            setTimeout(() => {
                phaseIndicator.style.display = 'none';
            }, 3000);
        }
        
        // 显示Boss技能指示器
        function showBossSkillIndicator(text) {
            const indicator = document.getElementById('bossSkillIndicator');
            indicator.textContent = text;
            indicator.style.display = 'block';
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }
        
        // 绘制玩家
        function drawPlayer() {
            if (player.image && player.image.complete) {
                ctx.drawImage(
                    player.image, 
                    player.x - player.width/2, 
                    player.y - player.height/2,
                    player.width,
                    player.height
                );
            } else {
                // 默认绘制（三角形飞船）
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y - player.height/2);
                ctx.lineTo(player.x - player.width/2, player.y + player.height/2);
                ctx.lineTo(player.x + player.width/2, player.y + player.height/2);
                ctx.closePath();
                ctx.fill();
                
                // 绘制玩家引擎效果
                ctx.fillStyle = '#ffa502';
                ctx.beginPath();
                ctx.moveTo(player.x - 10, player.y + player.height/2);
                ctx.lineTo(player.x, player.y + player.height/2 + 15);
                ctx.lineTo(player.x + 10, player.y + player.height/2);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        // 绘制Boss
        function drawBoss() {
            if (boss.image && boss.image.complete) {
                ctx.drawImage(
                    boss.image, 
                    boss.x - boss.width/2, 
                    boss.y - boss.height/2,
                    boss.width,
                    boss.height
                );
                
                // 如果使用图片，仍然绘制阶段特效
                if (bossPhase >= 2) {
                    // 绘制能量光环
                    ctx.strokeStyle = bossPhase === 2 ? '#ff3838' : '#b71540';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(boss.x, boss.y, boss.width/2 + 10, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // 第三阶段额外特效
                if (bossPhase === 3) {
                    // 绘制愤怒的红色光环
                    ctx.strokeStyle = '#ff3838';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(boss.x, boss.y, boss.width/2 + 25, 0, Math.PI * 2);
                    ctx.stroke();
                }
            } else {
                // 默认绘制（圆形Boss）
                ctx.fillStyle = boss.color;
                ctx.beginPath();
                ctx.arc(boss.x, boss.y, boss.width/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Boss眼睛 - 根据阶段改变颜色
                let eyeColor = '#000';
                if (bossPhase === 2) eyeColor = '#ffdd59';
                if (bossPhase === 3) eyeColor = '#ff3838';
                
                ctx.fillStyle = eyeColor;
                ctx.beginPath();
                ctx.arc(boss.x - 20, boss.y - 10, 10, 0, Math.PI * 2);
                ctx.arc(boss.x + 20, boss.y - 10, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // Boss嘴巴
                ctx.beginPath();
                if (bossPhase === 1) {
                    ctx.arc(boss.x, boss.y + 15, 25, 0, Math.PI, false);
                } else if (bossPhase === 2) {
                    // 第二阶段嘴巴张开更大
                    ctx.arc(boss.x, boss.y + 10, 30, 0, Math.PI, false);
                } else {
                    // 第三阶段愤怒的嘴巴
                    ctx.arc(boss.x, boss.y + 5, 35, 0, Math.PI, false);
                }
                ctx.strokeStyle = eyeColor;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 第二阶段特效
                if (bossPhase >= 2) {
                    // 绘制能量光环
                    ctx.strokeStyle = bossPhase === 2 ? '#ff3838' : '#b71540';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(boss.x, boss.y, boss.width/2 + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // 绘制能量粒子
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const x = boss.x + Math.cos(angle) * (boss.width/2 + 15);
                        const y = boss.y + Math.sin(angle) * (boss.width/2 + 15);
                        
                        ctx.fillStyle = bossPhase === 2 ? '#ff9f43' : '#ff3838';
                        ctx.beginPath();
                        ctx.arc(x, y, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 第三阶段额外特效
                if (bossPhase === 3) {
                    // 绘制愤怒的红色光环
                    ctx.strokeStyle = '#ff3838';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(boss.x, boss.y, boss.width/2 + 25, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // 绘制旋转的尖刺
                    const time = Date.now() / 200;
                    for (let i = 0; i < 12; i++) {
                        const angle = (i / 12) * Math.PI * 2 + time;
                        const x1 = boss.x + Math.cos(angle) * (boss.width/2 + 10);
                        const y1 = boss.y + Math.sin(angle) * (boss.width/2 + 10);
                        const x2 = boss.x + Math.cos(angle) * (boss.width/2 + 25);
                        const y2 = boss.y + Math.sin(angle) * (boss.width/2 + 25);
                        
                        ctx.strokeStyle = '#ff3838';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // 玩家发射子弹
        function playerShoot() {
            bullets.push({
                x: player.x,
                y: player.y - player.height/2,
                width: 5,
                height: 15,
                speed: 7,
                color: '#2ed573'
            });
        }
        
        // Boss发射子弹 - 普通攻击
        function bossShoot() {
            if (bossPhase === 1) {
                // 第一阶段攻击模式
                const attackType = Math.floor(Math.random() * 3);
                
                switch(attackType) {
                    case 0: // 直线射击
                        enemyBullets.push({
                            x: boss.x,
                            y: boss.y + boss.height/2,
                            width: 10,
                            height: 20,
                            speed: 5,
                            color: '#ff4757'
                        });
                        break;
                        
                    case 1: // 散射
                        for(let i = 0; i < 5; i++) {
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 8,
                                height: 15,
                                speed: 4,
                                color: '#ff9ff3',
                                angle: -Math.PI/2 + (i-2) * Math.PI/12
                            });
                        }
                        break;
                        
                    case 2: // 瞄准玩家射击
                        const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
                        enemyBullets.push({
                            x: boss.x,
                            y: boss.y + boss.height/2,
                            width: 8,
                            height: 15,
                            speed: 4,
                            color: '#ff6b6b',
                            angle: angle
                        });
                        break;
                }
            } else if (bossPhase === 2) {
                // 第二阶段攻击模式 - 更强大
                const attackType = Math.floor(Math.random() * 4);
                
                switch(attackType) {
                    case 0: // 快速直线射击
                        for (let i = 0; i < 3; i++) {
                            enemyBullets.push({
                                x: boss.x - 20 + i * 20,
                                y: boss.y + boss.height/2,
                                width: 8,
                                height: 15,
                                speed: 6,
                                color: '#ff3838'
                            });
                        }
                        break;
                        
                    case 1: // 密集散射
                        for(let i = 0; i < 8; i++) {
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 6,
                                height: 12,
                                speed: 5,
                                color: '#ff9f43',
                                angle: -Math.PI/2 + (i-4) * Math.PI/16
                            });
                        }
                        break;
                        
                    case 2: // 双重追踪
                        for (let i = 0; i < 2; i++) {
                            const offset = i === 0 ? -0.1 : 0.1;
                            const angle = Math.atan2(player.y - boss.y, player.x - boss.x) + offset;
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 8,
                                height: 15,
                                speed: 4.5,
                                color: '#ff6b6b',
                                angle: angle
                            });
                        }
                        break;
                        
                    case 3: // 环形攻击
                        for(let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 6,
                                height: 12,
                                speed: 4,
                                color: '#ff7979',
                                angle: angle
                            });
                        }
                        break;
                }
            } else {
                // 第三阶段攻击模式 - 极其强大
                const attackType = Math.floor(Math.random() * 5);
                
                switch(attackType) {
                    case 0: // 三重直线射击
                        for (let i = 0; i < 5; i++) {
                            enemyBullets.push({
                                x: boss.x - 40 + i * 20,
                                y: boss.y + boss.height/2,
                                width: 8,
                                height: 15,
                                speed: 7,
                                color: '#ff3838'
                            });
                        }
                        break;
                        
                    case 1: // 超级密集散射
                        for(let i = 0; i < 12; i++) {
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 6,
                                height: 12,
                                speed: 5.5,
                                color: '#ff9f43',
                                angle: -Math.PI/2 + (i-6) * Math.PI/20
                            });
                        }
                        break;
                        
                    case 2: // 三重追踪
                        for (let i = 0; i < 3; i++) {
                            const offset = (i - 1) * 0.15;
                            const angle = Math.atan2(player.y - boss.y, player.x - boss.x) + offset;
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 8,
                                height: 15,
                                speed: 5,
                                color: '#ff6b6b',
                                angle: angle
                            });
                        }
                        break;
                        
                    case 3: // 双环形攻击
                        for (let ring = 0; ring < 2; ring++) {
                            for(let i = 0; i < 16; i++) {
                                const angle = (i / 16) * Math.PI * 2;
                                enemyBullets.push({
                                    x: boss.x,
                                    y: boss.y + boss.height/2,
                                    width: 6,
                                    height: 12,
                                    speed: 4 + ring,
                                    color: ring === 0 ? '#ff7979' : '#ff3838',
                                    angle: angle
                                });
                            }
                        }
                        break;
                        
                    case 4: // 螺旋攻击
                        const time = Date.now() / 500;
                        for(let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2 + time;
                            enemyBullets.push({
                                x: boss.x,
                                y: boss.y + boss.height/2,
                                width: 6,
                                height: 12,
                                speed: 4,
                                color: '#ff9f43',
                                angle: angle
                            });
                        }
                        break;
                }
            }
        }
        
        // Boss特殊技能
        function bossSpecialSkill() {
            boss.skillCooldown = 300; // 5秒冷却（假设60fps）
            boss.skillType = Math.floor(Math.random() * 4);
            
            switch(boss.skillType) {
                case 0: // 激光攻击
                    showBossSkillIndicator("Boss使用了激光攻击!");
                    specialAttacks.push({
                        type: 'laser',
                        x: boss.x,
                        y: boss.y + boss.height/2,
                        width: 10,
                        height: canvas.height - boss.y,
                        color: '#ff3838',
                        timer: 60 // 持续1秒
                    });
                    break;
                    
                case 1: // 弹幕风暴
                    showBossSkillIndicator("Boss使用了弹幕风暴!");
                    for(let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        enemyBullets.push({
                            x: boss.x,
                            y: boss.y + boss.height/2,
                            width: 8,
                            height: 15,
                            speed: 3 + Math.random() * 3,
                            color: '#ff9f43',
                            angle: angle
                        });
                    }
                    break;
                    
                case 2: // 追踪导弹
                    showBossSkillIndicator("Boss发射了追踪导弹!");
                    for(let i = 0; i < 5; i++) {
                        specialAttacks.push({
                            type: 'homing',
                            x: boss.x - 40 + i * 20,
                            y: boss.y + boss.height/2,
                            width: 12,
                            height: 20,
                            color: '#ff6b6b',
                            speed: 3,
                            targetX: player.x,
                            targetY: player.y,
                            life: 300 // 5秒寿命
                        });
                    }
                    break;
                    
                case 3: // 区域爆炸
                    showBossSkillIndicator("Boss准备区域爆炸!");
                    specialAttacks.push({
                        type: 'explosion',
                        x: player.x,
                        y: player.y,
                        radius: 0,
                        maxRadius: 150,
                        color: '#ff3838',
                        timer: 90 // 1.5秒后爆炸
                    });
                    break;
            }
        }
        
        // 绘制子弹和特殊攻击
        function drawBullets() {
            // 玩家子弹
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
            });
            
            // 敌人子弹
            enemyBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.width, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // 特殊攻击
            specialAttacks.forEach(attack => {
                if (attack.type === 'laser') {
                    // 绘制激光
                    ctx.fillStyle = attack.color;
                    ctx.fillRect(attack.x - attack.width/2, attack.y, attack.width, attack.height);
                    
                    // 激光光效
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(attack.x - attack.width/2, attack.y);
                    ctx.lineTo(attack.x - attack.width/2, attack.y + attack.height);
                    ctx.moveTo(attack.x + attack.width/2, attack.y);
                    ctx.lineTo(attack.x + attack.width/2, attack.y + attack.height);
                    ctx.stroke();
                } else if (attack.type === 'homing') {
                    // 绘制追踪导弹
                    ctx.fillStyle = attack.color;
                    ctx.beginPath();
                    ctx.moveTo(attack.x, attack.y - attack.height/2);
                    ctx.lineTo(attack.x - attack.width/2, attack.y + attack.height/2);
                    ctx.lineTo(attack.x + attack.width/2, attack.y + attack.height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // 导弹尾焰
                    ctx.fillStyle = '#ffa502';
                    ctx.beginPath();
                    ctx.moveTo(attack.x - 5, attack.y + attack.height/2);
                    ctx.lineTo(attack.x, attack.y + attack.height/2 + 10);
                    ctx.lineTo(attack.x + 5, attack.y + attack.height/2);
                    ctx.closePath();
                    ctx.fill();
                } else if (attack.type === 'explosion') {
                    // 绘制爆炸区域
                    ctx.strokeStyle = attack.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(attack.x, attack.y, attack.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // 内部警告圈
                    if (attack.timer > 30) {
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(attack.x, attack.y, attack.radius * 0.7, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            });
        }
        
        // 更新子弹和特殊攻击
        function updateBullets() {
            // 更新玩家子弹
            for(let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bullets[i].speed;
                
                // 子弹超出屏幕
                if(bullets[i].y < 0) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // 检测子弹是否击中Boss
                if(
                    bullets[i].x > boss.x - boss.width/2 &&
                    bullets[i].x < boss.x + boss.width/2 &&
                    bullets[i].y > boss.y - boss.height/2 &&
                    bullets[i].y < boss.y + boss.height/2
                ) {
                    bullets.splice(i, 1);
                    bossHealth -= bossPhase === 1 ? 2 : (bossPhase === 2 ? 1.5 : 1); // 阶段越高越耐打
                    score += 10;
                    updateHealthBars();
                    
                    // 检查是否进入第二阶段
                    if(bossHealth <= BOSS_MAX_HEALTH * 2/3 && !boss.phase2Triggered) {
                        bossPhase = 2;
                        boss.phase2Triggered = true;
                        boss.attackRate = 40; // 第二阶段攻击更快
                        updatePhaseIndicator();
                    }
                    
                    // 检查是否进入第三阶段
                    if(bossHealth <= BOSS_MAX_HEALTH * 1/3 && !boss.phase3Triggered) {
                        bossPhase = 3;
                        boss.phase3Triggered = true;
                        boss.attackRate = 30; // 第三阶段攻击更快
                        boss.moveSpeed = 3; // 移动更快
                        updatePhaseIndicator();
                    }
                    
                    if(bossHealth <= 0) {
                        bossHealth = 0;
                        // Boss被击败，游戏胜利
                        gameOver = true;
                        document.getElementById('winScore').textContent = score;
                        document.getElementById('winScreen').style.display = 'flex';
                    }
                }
            }
            
            // 更新敌人子弹
            for(let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                if(bullet.angle) {
                    // 有角度的子弹（散射或追踪）
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                } else {
                    // 直线子弹
                    bullet.y += bullet.speed;
                }
                
                // 子弹超出屏幕
                if(
                    bullet.y > canvas.height ||
                    bullet.x < 0 ||
                    bullet.x > canvas.width
                ) {
                    enemyBullets.splice(i, 1);
                    continue;
                }
                
                // 检测子弹是否击中玩家
                if(
                    bullet.x > player.x - player.width/2 &&
                    bullet.x < player.x + player.width/2 &&
                    bullet.y > player.y - player.height/2 &&
                    bullet.y < player.y + player.height/2
                ) {
                    enemyBullets.splice(i, 1);
                    playerHealth -= bossPhase === 1 ? 10 : (bossPhase === 2 ? 15 : 20); // 阶段越高伤害越高
                    updateHealthBars();
                    
                    if(playerHealth <= 0) {
                        playerHealth = 0;
                        // 玩家死亡，游戏结束
                        gameOver = true;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('gameOverScreen').style.display = 'flex';
                    }
                }
            }
            
            // 更新特殊攻击
            for(let i = specialAttacks.length - 1; i >= 0; i--) {
                const attack = specialAttacks[i];
                
                if (attack.type === 'laser') {
                    attack.timer--;
                    if (attack.timer <= 0) {
                        specialAttacks.splice(i, 1);
                        continue;
                    }
                    
                    // 检测激光是否击中玩家
                    if(
                        player.x > attack.x - attack.width/2 &&
                        player.x < attack.x + attack.width/2 &&
                        player.y > attack.y
                    ) {
                        playerHealth -= 5; // 激光持续伤害
                        updateHealthBars();
                        
                        if(playerHealth <= 0) {
                            playerHealth = 0;
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverScreen').style.display = 'flex';
                        }
                    }
                } else if (attack.type === 'homing') {
                    // 追踪玩家
                    const dx = player.x - attack.x;
                    const dy = player.y - attack.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 10) {
                        attack.x += (dx / dist) * attack.speed;
                        attack.y += (dy / dist) * attack.speed;
                    }
                    
                    attack.life--;
                    if (attack.life <= 0) {
                        specialAttacks.splice(i, 1);
                        continue;
                    }
                    
                    // 检测追踪导弹是否击中玩家
                    if(
                        attack.x > player.x - player.width/2 &&
                        attack.x < player.x + player.width/2 &&
                        attack.y > player.y - player.height/2 &&
                        attack.y < player.y + player.height/2
                    ) {
                        specialAttacks.splice(i, 1);
                        playerHealth -= 25; // 导弹高伤害
                        updateHealthBars();
                        
                        if(playerHealth <= 0) {
                            playerHealth = 0;
                            gameOver = true;
                            document.getElementById('finalScore').textContent = score;
                            document.getElementById('gameOverScreen').style.display = 'flex';
                        }
                    }
                } else if (attack.type === 'explosion') {
                    attack.timer--;
                    attack.radius = (1 - attack.timer / 90) * attack.maxRadius;
                    
                    if (attack.timer <= 0) {
                        // 爆炸
                        const dx = player.x - attack.x;
                        const dy = player.y - attack.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < attack.maxRadius) {
                            playerHealth -= 30; // 爆炸高伤害
                            updateHealthBars();
                            
                            if(playerHealth <= 0) {
                                playerHealth = 0;
                                gameOver = true;
                                document.getElementById('finalScore').textContent = score;
                                document.getElementById('gameOverScreen').style.display = 'flex';
                            }
                        }
                        
                        specialAttacks.splice(i, 1);
                    }
                }
            }
        }
        
        // 使用技能
        function useSkill() {
            if (!skillAvailable || gameOver) return;
            
            // 清除所有敌人子弹和特殊攻击
            enemyBullets.length = 0;
            specialAttacks.length = 0;
            
            // 对Boss造成伤害
            bossHealth -= PLAYER_SKILL_DAMAGE;
            if (bossHealth < 0) bossHealth = 0;
            
            // 更新UI
            updateHealthBars();
            skillAvailable = false;
            updateSkillIndicator();
            
            // 技能特效
            drawSkillEffect();
            
            // 检查Boss阶段转换
            if(bossHealth <= BOSS_MAX_HEALTH * 2/3 && !boss.phase2Triggered) {
                bossPhase = 2;
                boss.phase2Triggered = true;
                boss.attackRate = 40;
                updatePhaseIndicator();
            }
            
            if(bossHealth <= BOSS_MAX_HEALTH * 1/3 && !boss.phase3Triggered) {
                bossPhase = 3;
                boss.phase3Triggered = true;
                boss.attackRate = 30;
                boss.moveSpeed = 3;
                updatePhaseIndicator();
            }
            
            // 检查Boss是否被击败
            if(bossHealth <= 0) {
                gameOver = true;
                document.getElementById('winScore').textContent = score;
                document.getElementById('winScreen').style.display = 'flex';
            }
        }
        
        // 绘制技能特效
        function drawSkillEffect() {
            // 绘制冲击波效果
            ctx.strokeStyle = '#2ed573';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 50, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = '#2ed573';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 100, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = '#2ed573';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 150, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // 更新游戏状态
        function update() {
            if(gameOver) return;
            
            // 更新玩家移动
            if (isTouching) {
                // 触摸控制
                const moveX = touchMoveX - touchStartX;
                const moveY = touchMoveY - touchStartY;
                
                // 限制移动范围
                const moveDistance = Math.min(Math.sqrt(moveX * moveX + moveY * moveY), 50);
                const angle = Math.atan2(moveY, moveX);
                
                player.x += Math.cos(angle) * moveDistance * 0.1;
                player.y += Math.sin(angle) * moveDistance * 0.1;
            } else {
                // 键盘控制
                if(keys['KeyW'] && player.y - player.height/2 > 0) {
                    player.y -= player.speed;
                }
                if(keys['KeyS'] && player.y + player.height/2 < canvas.height) {
                    player.y += player.speed;
                }
                if(keys['KeyA'] && player.x - player.width/2 > 0) {
                    player.x -= player.speed;
                }
                if(keys['KeyD'] && player.x + player.width/2 < canvas.width) {
                    player.x += player.speed;
                }
            }
            
            // 边界检查
            player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
            player.y = Math.max(player.height/2, Math.min(canvas.height - player.height/2, player.y));
            
            // 更新Boss移动（阶段2和3会移动）
            if (bossPhase >= 2) {
                boss.x += boss.moveSpeed * boss.moveDirection;
                
                // 边界反弹
                if (boss.x < boss.width/2 || boss.x > canvas.width - boss.width/2) {
                    boss.moveDirection *= -1;
                }
            }
            
            // 玩家自动射击
            if(Math.random() < 0.1) {
                playerShoot();
            }
            
            // Boss攻击
            boss.attackCooldown--;
            if(boss.attackCooldown <= 0) {
                bossShoot();
                boss.attackCooldown = boss.attackRate;
                
                // 阶段越高，连续攻击概率越高
                if (bossPhase >= 2 && Math.random() < 0.3) {
                    setTimeout(() => {
                        if (!gameOver) bossShoot();
                    }, 300);
                }
                
                // 第三阶段有时会三连击
                if (bossPhase === 3 && Math.random() < 0.2) {
                    setTimeout(() => {
                        if (!gameOver) bossShoot();
                    }, 300);
                    setTimeout(() => {
                        if (!gameOver) bossShoot();
                    }, 600);
                }
            }
            
            // Boss特殊技能
            boss.skillCooldown--;
            if(boss.skillCooldown <= 0 && bossPhase >= 2) {
                bossSpecialSkill();
            }
            
            // 更新子弹和特殊攻击
            updateBullets();
            
            // 增加分数
            score++;
            document.getElementById('score').textContent = score;
        }
        
        // 绘制游戏
        function draw() {
            // 清空画布
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制星空背景
            ctx.fillStyle = '#fff';
            for(let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 2;
                ctx.fillRect(x, y, size, size);
            }
            
            // 绘制游戏元素
            drawPlayer();
            drawBoss();
            drawBullets();
        }
        
        // 游戏循环
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // ===========================================
        // 事件监听
        // ===========================================
        
        // 键盘事件
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // 技能键K
            if (e.code === 'KeyK') {
                useSkill();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // 触摸事件
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchMoveX = touchStartX;
            touchMoveY = touchStartY;
            isTouching = true;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isTouching) return;
            
            const touch = e.touches[0];
            touchMoveX = touch.clientX;
            touchMoveY = touch.clientY;
        });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isTouching = false;
        });
        
        // 技能按钮点击事件
        document.getElementById('skillButton').addEventListener('click', useSkill);
        document.getElementById('skillButton').addEventListener('touchstart', (e) => {
            e.preventDefault();
            useSkill();
        });
        
        // 重新开始按钮
        document.getElementById('restartButton').addEventListener('click', init);
        document.getElementById('winRestartButton').addEventListener('click', init);
        
        // ===========================================
        // 启动游戏
        // ===========================================
        
        init();
        gameLoop();
    </script>
</body>
</html>